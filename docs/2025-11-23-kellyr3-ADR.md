# ADR-001: Unit Testing Strategy

**Status**: Accepted  
**Date**: 2025-11-23  
**Authors**: Ryan Kelly  

## Context

The Flutter app needs automated testing to prevent regressions and enable confident refactoring. Without tests, we risk breaking functionality, difficulty refactoring, and bugs in data serialization (Firestore Timestamps, JSON encoding).

**Key drivers**: Fast feedback loop, CI/CD integration, test isolation from external dependencies (Firebase, network, devices), tests as living documentation.

## Options

### Option 1: Unit Testing with Mocking (CHOSEN)

Unit tests for models and services using flutter_test with mockito. Mock SharedPreferences; skip AuthService (complex Firebase mocking).

**Evidence**: 42 tests run in ~2 seconds. Coverage: User Model (21 tests), MoodService (10 tests), PlacesService (11 tests).

**Pros**: Fast (2s), no dependencies, CI/CD ready, catches bugs early  
**Cons**: AuthService not tested, mocks don't catch all integration issues  

### Option 2: Integration Testing Only

Test complete user flows on device/emulator using `integration_test` package.

**Pros**: Tests real scenarios, catches integration issues  
**Cons**: Slow (~30s), requires emulator, flaky, hard to debug, complex CI/CD setup  

### Option 3: Do Nothing (Baseline)

Manual testing only, no automated tests.

**Pros**: No upfront time investment  
**Cons**: High regression risk, time-consuming, no behavior documentation, bugs found late  


## Decision

**Chosen: Option 1 - Unit Testing with Mocking**

**Rationale**: Created 42 tests covering critical functionality. Fast 2-second execution enables frequent testing. Integrated into CI/CD. Pragmatic approach focusing on testable code while deferring complex Firebase mocking.

**Trade-offs**: AuthService not tested (complex), not 100% coverage, tests need maintenance when APIs change.

## Consequences

**Positive**: Regression prevention, faster development, living documentation, quality gates in CI/CD, found Map type casting bugs

**Negative**: Maintenance overhead, partial coverage (AuthService/NotificationService untested), mock divergence from real behavior

**Neutral**: Requires team discipline to run tests before commits  

## References/Appendix

### Test Results
```bash
$ flutter test
00:02 +42: All tests passed!
```

### Code Examples

**MoodService Average Calculation**:
```dart
test('should calculate correct averages', () async {
  // Add 3 entries with different mood and stress levels
  await moodService.addEntry(MoodEntry(
    timestamp: now,
    moodLevel: 5,  // Happy
    stressLevel: 1, // Low stress
    notes: 'Great',
    userId: 'test-user',
  ));
  await moodService.addEntry(/* mood: 3, stress: 3 */);
  await moodService.addEntry(/* mood: 4, stress: 2 */);

  final averages = moodService.getAveragesForRange(start, end);
  
  expect(averages['moodAverage'], equals(4.0));  // (5+3+4)/3
  expect(averages['stressAverage'], equals(2.0)); // (1+3+2)/3
});
```

**PlacesService Geolocation** - Tests Haversine distance calculations with 50km radius around Portland coordinates.

### Test Coverage

| Component | Tests | Time | Coverage Areas |

| User Model | 21 | ~1.0s | Firestore serialization, copyWith, null handling |
| MoodService | 10 | ~0.5s | CRUD, date filtering, averages |
| PlacesService | 11 | ~0.5s | CRUD, Haversine distance, radius queries |
| **Total** | **42** | **~2s** | |

### Bug Discoveries

1. **Map Type Casting**: `UserPreferences.fromMap()` type error - fixed with `Map<String, dynamic>.from(prefsData)`
2. **Field Names**: Initial tests used wrong names (`moodRating`/`id` vs `moodLevel`/`userId`) - 64+ errors

### Dependencies
```yaml
dev_dependencies:
  mockito: ^5.4.4
  build_runner: ^2.4.13
```

### Documentation
- [Flutter Testing Guide](https://docs.flutter.dev/testing)
- [Mockito](https://pub.dev/packages/mockito)
- [SharedPreferences Testing](https://pub.dev/packages/shared_preferences#testing)
